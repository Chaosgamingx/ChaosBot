'use strict';

const EventEmitter = require('events');
const JSONB = require('json-buffer');

<<<<<<< HEAD
const loadStore = options => {
=======
const loadStore = opts => {
>>>>>>> 1442b7d2cd4ad5d1d6669e674737638da41e0996
	const adapters = {
		redis: '@keyv/redis',
		mongodb: '@keyv/mongo',
		mongo: '@keyv/mongo',
		sqlite: '@keyv/sqlite',
		postgresql: '@keyv/postgres',
		postgres: '@keyv/postgres',
<<<<<<< HEAD
		mysql: '@keyv/mysql',
	};
	if (options.adapter || options.uri) {
		const adapter = options.adapter || /^[^:]*/.exec(options.uri)[0];
		return new (require(adapters[adapter]))(options);
=======
		mysql: '@keyv/mysql'
	};
	if (opts.adapter || opts.uri) {
		const adapter = opts.adapter || /^[^:]*/.exec(opts.uri)[0];
		return new (require(adapters[adapter]))(opts);
>>>>>>> 1442b7d2cd4ad5d1d6669e674737638da41e0996
	}

	return new Map();
};

class Keyv extends EventEmitter {
<<<<<<< HEAD
	constructor(uri, options) {
=======
	constructor(uri, opts) {
>>>>>>> 1442b7d2cd4ad5d1d6669e674737638da41e0996
		super();
		this.opts = Object.assign(
			{
				namespace: 'keyv',
				serialize: JSONB.stringify,
<<<<<<< HEAD
				deserialize: JSONB.parse,
			},
			(typeof uri === 'string') ? { uri } : uri,
			options,
		);

		if (!this.opts.store) {
			const adapterOptions = Object.assign({}, this.opts);
			this.opts.store = loadStore(adapterOptions);
		}

		if (typeof this.opts.store.on === 'function') {
			this.opts.store.on('error', error => this.emit('error', error));
=======
				deserialize: JSONB.parse
			},
			(typeof uri === 'string') ? { uri } : uri,
			opts
		);

		if (!this.opts.store) {
			const adapterOpts = Object.assign({}, this.opts);
			this.opts.store = loadStore(adapterOpts);
		}

		if (typeof this.opts.store.on === 'function') {
			this.opts.store.on('error', err => this.emit('error', err));
>>>>>>> 1442b7d2cd4ad5d1d6669e674737638da41e0996
		}

		this.opts.store.namespace = this.opts.namespace;
	}

	_getKeyPrefix(key) {
		return `${this.opts.namespace}:${key}`;
	}

<<<<<<< HEAD
	get(key, options) {
=======
	get(key, opts) {
>>>>>>> 1442b7d2cd4ad5d1d6669e674737638da41e0996
		const keyPrefixed = this._getKeyPrefix(key);
		const { store } = this.opts;
		return Promise.resolve()
			.then(() => store.get(keyPrefixed))
<<<<<<< HEAD
			.then(data => (typeof data === 'string') ? this.opts.deserialize(data) : data)
=======
			.then(data => {
				return (typeof data === 'string') ? this.opts.deserialize(data) : data;
			})
>>>>>>> 1442b7d2cd4ad5d1d6669e674737638da41e0996
			.then(data => {
				if (data === undefined) {
					return undefined;
				}

				if (typeof data.expires === 'number' && Date.now() > data.expires) {
					this.delete(key);
					return undefined;
				}

<<<<<<< HEAD
				return (options && options.raw) ? data : data.value;
=======
				return (opts && opts.raw) ? data : data.value;
>>>>>>> 1442b7d2cd4ad5d1d6669e674737638da41e0996
			});
	}

	set(key, value, ttl) {
		const keyPrefixed = this._getKeyPrefix(key);
		if (typeof ttl === 'undefined') {
			ttl = this.opts.ttl;
		}

		if (ttl === 0) {
			ttl = undefined;
		}

		const { store } = this.opts;

		return Promise.resolve()
			.then(() => {
				const expires = (typeof ttl === 'number') ? (Date.now() + ttl) : null;
				value = { value, expires };
				return this.opts.serialize(value);
			})
			.then(value => store.set(keyPrefixed, value, ttl))
			.then(() => true);
	}

	delete(key) {
		const keyPrefixed = this._getKeyPrefix(key);
		const { store } = this.opts;
		return Promise.resolve()
			.then(() => store.delete(keyPrefixed));
	}

	clear() {
		const { store } = this.opts;
		return Promise.resolve()
			.then(() => store.clear());
	}
}

module.exports = Keyv;
